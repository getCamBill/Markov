import re
import numpy as np
import matplotlib.pyplot as plt
import scipy.stats



def est_transition(Matrice: list):
    assert Matrice.ndim == 2, "N'est pas une matrice 2D"
    assert Matrice.shape[0] == Matrice.shape[1], "La matrice n'est pas carré"
    np.testing.assert_allclose(np.sum(Matrice, 1), [1] * Matrice.shape[0], err_msg='La somme des probas ne fait pas 1')


def simu(Q, Xo, n):
    """
    fonction simu renvoyant une trajectoire de la chaîne de Markov
    jusqu'au temps n.

    :param Q:matrice de transition
    :param Xo: condition initiale, qui peut être une variable aléatoire
    :param n:temps n
    :return: trajectoire de la chaîne de Markov
    """

    trajectoire = []

    # Condition initiales:
    x0 = int(np.random.random() < Xo)
    # x0 = Xo
    trajectoire.append(x0)

    # Chaque pas de temps
    for t in range(n - 1):
        x = trajectoire[-1]
        rd = np.random.random()
        if x == 0:
            if rd < P[0, 1]:
                new_x = 1
            else:
                new_x = 0
        else:
            new_x = int(rd < P[1, 1])
        trajectoire.append(new_x)
    return trajectoire


# trace_mc_trajectoire(traj, ['Fermé','Ouvert'])


def trouver_mesure_invariante(P):
    """Retourne la mesure invariante d'une matrice stochastique P"""

    # Tester si la matrice est stochastique.
    est_transition(P)

    # Trouver le vecteur propre à gauche
    # /!\ linalg.eig renvoie la valeur propre à droite,
    # il faut transposer la matrice de départ pour avoir
    # celle à gauche. Exercice: le prouver.
    valp, vecp = np.linalg.eig(P.transpose())

    # Trouver la valeur propre dominante
    # On sait qu'elle existe grâce au thèorème de Perron-Frobenius.
    pos_valp_dom = np.argmax(valp)
    vecp_dom = vecp[:, pos_valp_dom]

    # Vérifier que la valeur propre dominante est 1.
    assert abs(np.max(valp) - 1) < 1e-10

    # Trouver le vecteur propre dominant
    # et le remettre à l'échelle pour que la somme
    # de ses éléments soit 1.
    vecp_dom = vecp[:, pos_valp_dom] / np.sum(vecp_dom)

    return vecp_dom
P = np.array([[0, 2/7, 2/7, 3/7],
              [3/17, 9/17, 5/17, 0],
              [1/4, 1/4, 1/4, 1/4],
              [1/3, 1/3, 1/3, 0]])
print(trouver_mesure_invariante(P))

def finale(Q, Xo, n):
    liste = []
    for i in range(0, n):
        liste[i] = simu(Q, Xo, n)[n]
    return liste

P = np.array([[0, 2/7, 2/7, 3/7],
              [3/17, 9/17, 5/17, 0],
              [1/4, 1/4, 1/4, 1/4],
              [1/3, 1/3, 1/3, 0]])
traj = simu(P, 0.9, 10)
print(traj)

f = finale(P, 0.9, 10)
print(f)

# ---------------------------------------
"""
(d) 
Écrire une fonction permettant de calculer le nombre moyen de fois,
noté Mn, que la chaîne réalise le motif 123 lors d'une trajectoire
en fonction de n.
"""

# l = [1, 2, 3, 2, 3, 1, 1, 2, 3]
# matches = re.findall('123', "".join(map(str, [1, 2, 3, 2, 3, 1, 1, 2, 3])), re.DOTALL)
# print(matches, len(matches))


# ---------------------------------------

def trace_mc_trajectoire(traj, noms_etats=None, ax=None):
    """Trace la trajectoire d'une chaîne de markov.

    Args:
        traj (np.array): traj[i] est l'état de la chaîne à l'instant i.
        noms_etats (iterable): nom associé à chaque état
        ax (matplotlib.axis): axis on which the trajectory is drawn
    """
    if ax is None:
        fig, ax = plt.subplots(figsize=(15, 2))
    ticks = np.arange(traj.max() + 1)
    if noms_etats is None:
        noms_etats = ticks
    ax.plot(np.arange(len(traj)), traj, color='k')
    ax.set(xlabel='Temps', ylabel='État', yticks=ticks, yticklabels=noms_etats)
    ax.scatter(np.arange(len(traj)), traj)