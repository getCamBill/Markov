import re
import numpy as np
import matplotlib.pyplot as plt

"""
(a) Écrire une fonction simu, prenant pour paramètres Q, X0 et un
entier n, et renvoyant une trajectoire de la chaîne de Markov
jusqu'au temps n.
"""
def simu(Q, Xo, n):
    """
    fonction simu renvoyant une trajectoire de la chaîne de Markov
    jusqu'au temps n.

    :param Q:matrice de transition
    :param Xo: condition initiale, qui peut être une variable aléatoire
    :param n:temps n
    :return: trajectoire de la chaîne de Markov
    """
    # Condition initiales:
    x0 = int(np.random.random() < Xo)
    trajectoire = []
    trajectoire.append(x0)
    for t in range(1, n + 1):
        _1 = Q[x0-1,0]
        _2 = _1 + Q[x0 - 1, 1]
        _3 = _2 + Q[x0 - 1, 2]
        rd = np.random.random()
        if rd < _1:
            x0 = 1
        elif rd < _2:
            x0 = 2
        elif rd < _3:
            x0 = 3
        else:
            x0 = 4
        trajectoire.append(x0)

    return trajectoire

def trouver_mesure_invariante(Pi):
    """
    Permet de retrouver les mesures invariantes
    :param Pi: matrice stochastique
    :return:
    """
    pi1 = Pi.transpose() # il faut transposer la matrice de départ
    propre = np.linalg.eig(pi1)[1] # le vecteur propre
    return abs(propre[:, 0]/sum(abs(propre[:, 0]))).transpose()

"""
(d) 
Écrire une fonction permettant de calculer le nombre moyen de fois,
noté Mn, que la chaîne réalise le motif 123 lors d'une trajectoire
en fonction de n.
"""
def Mn(Q, Xo, n, N):
    somme = []

    def motif(traj: list) -> int:
        nb = len(re.findall('123', "".join(map(str, traj)), re.DOTALL))
        return nb

    for i in range(1, N):
        somme.append(motif(simu(Q, Xo, n)))
    return sum(somme)/n, somme

def show(Mn: list, idnum: int) -> plt:
    if idnum != 1:
        chaine_1 = "Graphe de la suite Mn"
        chaine_2 = "Nb apparition du motif '123'"
        chaine_3 = "n simulation"
    else:
        chaine_1 = "Graphe de la trajectoire de Markov"
        chaine_2 = "Etats"
        chaine_3 = "temps n"

    taille = len(Mn)
    copernic = [ i for i in range(taille)]
    plt.scatter(copernic, Mn, color='firebrick')
    plt.plot(copernic, Mn, color='darkslategrey')
    plt.title(chaine_1)
    plt.xlabel(chaine_3)
    plt.ylabel(chaine_2)
    plt.show()

# --------------------------------------
# X_0 = np.random.randint(1, 15)
X_0 = 10

# (a)
P = np.array([[0, 2/7, 2/7, 3/7],
              [3/17, 9/17, 5/17, 0],
              [1/4, 1/4, 1/4, 1/4],
              [1/3, 1/3, 1/3, 0]])
Riazan = simu(P, X_0, 10) # ville de naissance de Andreï Andreïevitch Markov, un mec connu
print("Trajectoire : ",Riazan)
show(Riazan, 1)
# (d)
print("Mesure invarainte : ",trouver_mesure_invariante(P))
blobe = Mn(P, X_0, 10, 100)
print("Pour n = 100 :", blobe[0])
show(blobe[1], 2)
blobe = Mn(P, X_0, 10, 1000)
print("Pour n = 1 000 :", blobe[0])
show(blobe[1], 2)
blobe = Mn(P, X_0, 10, 10000)
print("Pour n = 10 000 :", blobe[0])
# show(blobe[1], 2)
blobe = Mn(P, X_0, 10, 100000)
print("Pour n = 100 000 :", blobe[0])
# show(blobe[1], 2)


# ---------------------------------------